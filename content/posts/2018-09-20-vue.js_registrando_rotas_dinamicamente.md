---
date: 2018-09-20T09:00:00.029Z
title: (Vue.js) Registrando rotas dinamicamente
subtitle: Como fazer de forma inteligente para o roteador do Vue.js (vue-router) carregar as rotas da sua aplicação e criar um menu simples baseado nisso.
published: false
isPortuguese: true
tags:
  - vuejs
---

# Introdução

A ideia dessa postagem é mostrar uma forma melhor de configurar o roteador e gerar um menu simples para qualquer aplicação que tenha (ou vá ter) muitas rotas.

Então, caso sua aplicação tenha cerca de dez ou mais rotas, podendo alcançar quem sabe cinquenta ou até mais que isso, ou qualquer outra quantidade de rotas que você considere muito, o suficiente para que você tenha que escrever um _array_ desse mesmo tamanho, onde cada elemento dele terá em torno de três propriedades (_path_, _name_, _component_).

Vejamos então, considerando cinquenta rotas, você provavelmente terá um arquivo com mais de 150 linhas, **apenas** com essas rotas.

O que vou propor é uma outra forma de carregar essas rotas, escrevendo-as de forma parcial junto com cada _template_ da aplicação.

# Criando uma aplicação com roteador

Vamos utilizar o [_vue-cli_](https://cli.vuejs.org/vue-cli) para [inicializar um projeto](https://cli.vuejs.org/guide/creating-a-project.html#vue-create) chamado _minha-cozinha_.

```sh
$ vue create minha-cozinha
```

Depois disso, teremos o esqueleto da nossa aplicação pronto para começar, vamos adicionar o _plugin_ do _router_.

```sh
$ cd minha-cozinha
$ vue add router
```

## Criando o menu

O CLI inicia o projeto e podemos ver que no arquivo `App.vue` foi criado um `router-link` para cada uma das páginas existentes, vamos apagar isso e criar um componente `src/components/MenuNav.vue` que representa o nosso menu, que será um _array_ com o seguinte formato:

```javascript
[
  {
    nome: "Menu 1",
    submenu: [
      {
        agregador: "Menu 1",
        nome: "Submenu 1.1",
        rota: "/menu1/submenu11"
      },
      {
        agregador: "Menu 1",
        nome: "Submenu 1.2",
        rota: "/menu1/submenu12"
      }
    ]
  }
  // ...
];
```

Conhecendo esse formato, podemos escrever o nosso componente `MenuNav`, ele vai obter o menu através da variável `$menu` da instância do Vue, ela será atribuída no momento que as rotas da aplicação forem processadas.
O componente de menu é bem simples, fazemos um laço no _array_ `menu` e na sua propriedade `submenu`, daí conseguimos montar uma lista encadeada e aplicamos algumas regras CSS para que isso seja exibido como um menu no topo da aplicação.

```html
<template>
  <nav id="nav">
    <ul>
      <li :key="m.nome" v-for="m in menu">
        <a href="#">{{ m.nome }}</a>
        <ul>
          <li :key="sm.nome" v-for="sm in m.submenu">
            <router-link :to="sm.rota">{{ sm.nome }}</router-link>
          </li>
        </ul>
      </li>
    </ul>
  </nav>
</template>

<script>
  export default {
    name: "MenuNav",
    data() {
      return {
        menu: this.$menu
      };
    }
  };
</script>

<style>
  #nav {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    border: 1px solid #ccc;
  }

  #nav ul {
    list-style: none;
    float: left;
    margin: 0;
    padding: 0;
  }

  #nav ul a {
    display: block;
    color: #333;
    text-decoration: none;
    font-weight: 700;
    font-size: 12px;
    line-height: 32px;
    padding: 0 15px;
  }

  #nav ul li {
    position: relative;
    float: left;
    margin: 0;
    padding: 0;
  }

  #nav ul li:hover {
    background: #f6f6f6;
  }

  #nav ul ul {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: #fff;
    padding: 0;
    border: 1px solid #ccc;
  }

  #nav ul ul li {
    float: none;
    width: 200px;
  }

  #nav ul ul a {
    line-height: 120%;
    padding: 10px 15px;
  }

  #nav ul ul ul {
    top: 0;
    left: 100%;
  }

  #nav ul li:hover > ul {
    display: block;
  }
</style>
```

No nosso `App.vue` adicionaremos o menu e mais algumas regras CSS.

```html
<template>
  <div id="app">
    <menu-nav />
    <router-view />
  </div>
</template>

<script>
  import MenuNav from "@/components/MenuNav";

  export default {
    components: { MenuNav }
  };
</script>

<style>
  #app {
    font-family: "Avenir", Helvetica, Arial, sans-serif;
    margin-top: 60px;
  }
</style>
```

## Criando outras páginas e os roteamentos

Agora, vamos criar os seguintes arquivos em seus respectivos diretórios para a nossa aplicação:

- receita/
  - ReceitaConsulta.vue
  - ReceitaCadastro.vue
- fornecedor/
  - FornecedorConsulta.vue
  - FornecedorCadastro.vue
- produto/
  - ProdutoConsulta.vue
  - ProdutoCadastro.vue
- equipamento/
  - EquipamentoConsulta.vue
  - EquipamentoCadastro.vue
- equipe/
  - EquipeConsulta.vue
  - EquipeCadastro.vue
- profissional/
  - ProfissionalConsulta.vue
  - ProfissionalCadastro.vue
- cliente/
  - ClienteConsulta.vue
  - ClienteCadastro.vue
- usuario/
  - UsuarioConsulta.vue
  - UsuarioCadastro.vue
- Login.vue
- 404.vue
- 401.vue

Em cada um desses arquivos, adicionei um `template` com uma marcação `h1` apenas para exibir um texto quando o componente ocupar o `router-view`.

Veja que o foco aqui é como informar ao `router` tudo que ele precisa saber sobre esses componentes para que quando uma determinada rota for solicitada o componente correspondente a ela seja exibido.
De modo quase que automático, geralmente continuamos aumentando o _array_ que já existe no arquivo `router.js` e que o CLI adicionou ao nosso projeto.
Mas existe um modo melhor.
Em cada uma das pastas, um arquivo chamado `rotas.js` vai ser criado e nele vai existir uma exportação de um _array_ contendo as rotas dos respectivos componentes.
Cada rota teremos os seguintes atributos:

- `path`: Endereço da rota.
- `name`: Nome da rota.
- `component`: Componente que deve ser renderizado.
- `meta`: Usado para colocar qualquer outra informação referente a rota.
  - `menu`: Objeto que representa o menu da respectiva rota.
    - `agregador`: Menu raiz desse menu, vazio caso não tenha (e.g. Home, Sobre)
    - `nome`: Texto a ser exibido.

Por exemplo em `cliente/rotas.js` seria algo assim:

```javascript
const ClienteConsulta = () => import("./ClienteConsulta");
const ClienteCadastro = () => import("./ClienteCadastro");

export default [
  {
    path: "/cliente/cadastro",
    name: "ClienteCadastro",
    component: ClienteCadastro,
    meta: {
      menu: {
        agregador: "Cliente",
        nome: "Cadastrar"
      }
    }
  },
  {
    path: "/cliente",
    name: "ClienteConsulta",
    component: ClienteConsulta,
    meta: {
      menu: {
        agregador: "Cliente",
        nome: "Consultar"
      }
    }
  }
];
```

Certo, então basta criar um arquivo semelhante a esse em cada uma dessas pastas e alterar o `router.js` para identificá-los e carregá-los, assim como as rotas que estão neles, elas devem se tornar um único _array_ e ser usado no construtor do `vue-router`.
O arquivo `router.js`, que antes teria a responsabilidade de conhecer todas as rotas da sua aplicação se tornará um "simples processador", ele terá três responsabilidades.

- Ler todos os arquivos `rotas.js` e gerar um array de rotas para o construtor do `vue-router`,
- Gerar também um _array_ menu e atribuí-lo a `Vue.prototype.$menu`,
- Por fim, exportar a instância do roteador.

O nosso arquivo `router.js` seria algo assim:

```javascript
import Vue from "vue";
import Router from "vue-router";

const importAll = r => {
  return r.keys().map(r);
};
const importRotas = importAll(require.context(".", true, /rotas.js$/));

// Gera um array contendo todas as rotas.
const routes = importRotas.map(r => r.default).reduce((a, b) => a.concat(b));

// A partir das rotas geradas, cria um array a partir do que for encontrado em meta.menu
const menu = routes
  .reduce(
    (a, b) =>
      b.meta
        ? a.concat({
            nome: b.meta.menu.nome,
            agregador: b.meta.menu.agregador,
            rota: b.path
          })
        : a,
    []
  )
  .reduce((a, b) => {
    const menuItem = a.find(a => a.nome === b.agregador);
    if (menuItem) {
      menuItem.submenu.push(b);
    } else {
      a.push({ nome: b.agregador, submenu: [b] });
    }
    return a;
  }, []);

Vue.use(Router);
Vue.prototype.$menu = menu;

export default new Router({
  mode: "history",
  base: process.env.BASE_URL,
  routes
});
```

O `require.context` que torna possível essa implementação é fornecido pelo [Webpack](http://webpack.js.org/) utilizado pelo CLI, além disso usamos alguns `map().reduce()` para gerar tanto o array de rotas do roteador quanto o nosso menu para o componente `MenuNav`.

# Conclusão

Cadastrar rotas da forma mostrada aqui nos dá o benefício de isolar mais essa responsabilidade e nos incentiva a buscar uma aplicação mais modularizada. A implementação completa pode ser vista nesse [repositório](https://github.com/joelxr/minha-cozinha/tree/v0.1).
